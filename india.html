<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive India Map</title>
    <style>
        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* UI: TOP BAR */
        #top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        #magic-box {
            background: #f0f4f8;
            border: 2px solid #007bff;
            color: #007bff;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
            min-width: 100px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #magic-box.active {
            background: #007bff;
            color: white;
            box-shadow: 0 0 8px rgba(0,123,255,0.4);
        }

        #undo-btn {
            background: #ff4757;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
        }

        #undo-btn:active {
            background: #e04050;
        }

        /* MAP CONTAINER */
        #scroll-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            position: relative;
            touch-action: pan-x pan-y; 
            background-color: #ffffff;
            padding-top: 60px; 
        }

        #map-content {
            position: relative;
            transform-origin: 0 0;
            will-change: width, height;
        }

        #map-image {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain; 
            pointer-events: none; 
        }

        /* LABELS & DOTS */
        .map-label {
            position: absolute;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            cursor: pointer;
            transition: transform 0.1s ease; /* Smooth scaling for press effect */
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Visual feedback classes */
        .map-label.pressing {
            transform: translate(-50%, -50%) scale(0.9);
            opacity: 0.8;
        }

        .map-label.deleting .label-dot,
        .map-label.deleting .label-text {
            background-color: #ff0000 !important;
            border-color: #ff0000 !important;
            color: white !important;
        }

        .label-dot {
            width: 12px;
            height: 12px;
            background-color: #ff3f34; 
            border: 2px solid #ffffff;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
            margin-bottom: 2px;
            pointer-events: none; /* Let clicks pass to wrapper */
        }

        .label-text {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            color: #000;
            white-space: nowrap;
            font-weight: 700;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            text-align: center;
            pointer-events: none; /* Let clicks pass to wrapper */
        }

        @keyframes popIn {
            from { transform: translate(-50%, -50%) scale(0); }
            to { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <div id="magic-box">Tap to Start</div>
        <button id="undo-btn">Undo</button>
    </div>

    <div id="scroll-container">
        <div id="map-content">
            <img id="map-image" src="https://iili.io/flPbTaj.jpg" alt="India Map">
        </div>
    </div>

<script>
    /** STATE MANAGEMENT */
    const INDIAN_STATES = [
        "Andhra Pradesh", "Arunachal Pradesh", "Assam", "Bihar", "Chhattisgarh",
        "Goa", "Gujarat", "Haryana", "Himachal Pradesh", "Jharkhand",
        "Karnataka", "Kerala", "Madhya Pradesh", "Maharashtra", "Manipur",
        "Meghalaya", "Mizoram", "Nagaland", "Odisha", "Punjab",
        "Rajasthan", "Sikkim", "Tamil Nadu", "Telangana", "Tripura",
        "Uttar Pradesh", "Uttarakhand", "West Bengal", "Andaman & Nicobar",
        "Chandigarh", "Dadra & Nagar Haveli", "Delhi", "Jammu & Kashmir",
        "Ladakh", "Lakshadweep", "Puducherry"
    ];

    const STORAGE_KEY = 'india_map_labels_v4';
    
    // Zoom/Dimension State
    let minCoverWidth = 0; 
    let maxZoomWidth = 0;
    
    // Game State
    let placedLabels = []; 
    let availableStates = [];
    let currentTargetState = null;
    let isWaitingForPlacement = false;

    // Elements
    const scrollContainer = document.getElementById('scroll-container');
    const mapContent = document.getElementById('map-content');
    const mapImage = document.getElementById('map-image');
    const magicBox = document.getElementById('magic-box');
    const undoBtn = document.getElementById('undo-btn');

    /** INITIALIZATION */
    function init() {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) placedLabels = JSON.parse(saved);
        
        resetAvailableStates();
        renderLabels();
        updateMagicBox(false);

        if (mapImage.complete) {
            setupDimensions();
        } else {
            mapImage.onload = setupDimensions;
        }
    }

    function setupDimensions() {
        const imgW = mapImage.naturalWidth || 1000;
        const imgH = mapImage.naturalHeight || 1000;
        const imgAspect = imgW / imgH;
        const screenW = window.innerWidth;
        const screenH = window.innerHeight;
        
        const widthToCoverHeight = screenH * imgAspect;
        const widthToCoverWidth = screenW;

        minCoverWidth = Math.max(widthToCoverWidth, widthToCoverHeight);
        maxZoomWidth = minCoverWidth * 3;

        mapContent.style.width = `${minCoverWidth}px`;
        mapContent.style.height = 'auto'; 
    }

    /** GAMEPLAY */
    function resetAvailableStates() {
        const placedNames = placedLabels.map(l => l.name);
        availableStates = INDIAN_STATES.filter(s => !placedNames.includes(s));
    }

    function pickRandomState() {
        resetAvailableStates();
        if (availableStates.length === 0) return null;
        return availableStates[Math.floor(Math.random() * availableStates.length)];
    }

    function updateMagicBox(isActive) {
        if (availableStates.length === 0 && !isActive) {
            magicBox.textContent = "All Done!";
            magicBox.classList.remove('active');
            return;
        }
        if (isActive && currentTargetState) {
            magicBox.textContent = `Place: ${currentTargetState}`;
            magicBox.classList.add('active');
            isWaitingForPlacement = true;
        } else {
            magicBox.classList.remove('active');
            isWaitingForPlacement = false;
            if (!currentTargetState) currentTargetState = pickRandomState();
            magicBox.textContent = currentTargetState ? currentTargetState : "Complete";
        }
    }

    magicBox.addEventListener('click', () => {
        if (availableStates.length === 0) return;
        if (!isWaitingForPlacement) updateMagicBox(true); 
        else {
            isWaitingForPlacement = false;
            magicBox.classList.remove('active');
        }
    });

    undoBtn.addEventListener('click', () => {
        if (placedLabels.length > 0) {
            placedLabels.pop();
            saveAndRender();
            currentTargetState = null; 
            resetAvailableStates();
            currentTargetState = pickRandomState();
            updateMagicBox(false);
        }
    });

    mapContent.addEventListener('click', (e) => {
        if (!isWaitingForPlacement) return;
        if (e.target.closest('.map-label')) return;

        const rect = mapContent.getBoundingClientRect();
        const xPercent = ((e.clientX - rect.left) / rect.width) * 100;
        const yPercent = ((e.clientY - rect.top) / rect.height) * 100;

        placedLabels.push({
            id: Date.now(),
            name: currentTargetState,
            x: xPercent,
            y: yPercent
        });

        saveAndRender();
        isWaitingForPlacement = false;
        currentTargetState = null;
        resetAvailableStates();
        currentTargetState = pickRandomState();
        updateMagicBox(false);
    });

    function saveAndRender() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(placedLabels));
        renderLabels();
    }

    function renderLabels() {
        document.querySelectorAll('.map-label').forEach(el => el.remove());
        
        placedLabels.forEach(data => {
            const wrapper = document.createElement('div');
            wrapper.className = 'map-label';
            wrapper.style.left = `${data.x}%`;
            wrapper.style.top = `${data.y}%`;

            const dot = document.createElement('div');
            dot.className = 'label-dot';

            const text = document.createElement('div');
            text.className = 'label-text';
            text.textContent = data.name;

            wrapper.appendChild(dot);
            wrapper.appendChild(text);

            attachLongPress(wrapper, data.id);
            mapContent.appendChild(wrapper);
        });
    }

    function attachLongPress(element, id) {
        let timer;
        
        const start = (e) => {
            // Visual feedback: Shrink
            element.classList.add('pressing');

            timer = setTimeout(() => {
                // 1. Visual Feedback: Red flash
                element.classList.remove('pressing');
                element.classList.add('deleting');

                // 2. Haptic Feedback (Try catch for safety)
                try {
                    if (navigator.vibrate) {
                        navigator.vibrate(200); 
                    }
                } catch (err) { console.log("Vibration not supported"); }

                // 3. Deletion (Small delay to let user see the red flash)
                setTimeout(() => {
                    placedLabels = placedLabels.filter(l => l.id !== id);
                    saveAndRender();
                    resetAvailableStates();
                    
                    if (!currentTargetState) {
                        currentTargetState = pickRandomState();
                        updateMagicBox(false);
                    }
                }, 50); // Tiny delay for visual registration

            }, 600); // 600ms hold time
        };

        const cancel = () => { 
            if (timer) clearTimeout(timer); 
            element.classList.remove('pressing');
            element.classList.remove('deleting');
        };

        // Touch listeners
        element.addEventListener('touchstart', start, {passive: true});
        element.addEventListener('touchend', cancel);
        element.addEventListener('touchmove', cancel);
        
        // Mouse listeners (for desktop testing)
        element.addEventListener('mousedown', start);
        element.addEventListener('mouseup', cancel);
        element.addEventListener('mouseleave', cancel);
    }

    /** ZOOM LOGIC */
    let startDist = 0;
    let startWidth = 0; 
    let isPinching = false;

    scrollContainer.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            isPinching = true;
            startDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );
            startWidth = mapContent.getBoundingClientRect().width;
            e.preventDefault();
        }
    }, { passive: false });

    scrollContainer.addEventListener('touchmove', (e) => {
        if (isPinching && e.touches.length === 2) {
            e.preventDefault();

            const currentDist = Math.hypot(
                e.touches[0].clientX - e.touches[1].clientX,
                e.touches[0].clientY - e.touches[1].clientY
            );

            const scaleFactor = currentDist / startDist;
            let newWidth = startWidth * scaleFactor;

            if (newWidth < minCoverWidth) newWidth = minCoverWidth;
            if (newWidth > maxZoomWidth) newWidth = maxZoomWidth;

            const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
            const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

            const scrollLeft = scrollContainer.scrollLeft;
            const scrollTop = scrollContainer.scrollTop;
            
            const contentX = scrollLeft + midX; 
            const contentY = scrollTop + midY - 60; 

            const currentDOMWidth = mapContent.offsetWidth;
            const currentDOMHeight = mapContent.offsetHeight;

            const ratioX = contentX / currentDOMWidth;
            const ratioY = contentY / currentDOMHeight;

            mapContent.style.width = `${newWidth}px`;
            
            const newDOMWidth = mapContent.offsetWidth; 
            const newDOMHeight = mapContent.offsetHeight;

            const newContentX = ratioX * newDOMWidth;
            const newContentY = ratioY * newDOMHeight;

            scrollContainer.scrollLeft = newContentX - midX;
            scrollContainer.scrollTop = newContentY - midY + 60;
        }
    }, { passive: false });

    scrollContainer.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) isPinching = false;
    });

    window.addEventListener('resize', () => {
        setupDimensions();
    });

    init();

</script>
</body>
</html>